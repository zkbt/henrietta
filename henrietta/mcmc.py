from astropy.modeling import models, fitting, optimizers, statistic, custom_model
import numpy as np
import emcee
import batman
import sys

"""

This script takes in an astropy transit model and a lightkurve object,
determines which parameters are variable, and runs an MCMC
to fit those parameters and create a maximum likelihood model.

"""

def lnprob(params):

    n = len(astropy_model.param_names)

    i = 0
    for k in astropy_model.param_names:
        if astropy_model.fixed[k] == False:
            for m in range(n):
                if astropy_model.param_names[m] == str(k):
                    astropy_model.parameters[m] = params[i]
                    i += 1

    if (astropy_model.a <= astropy_model.b):
        astropy_model.a = astropy_model.b + 0.01

    model = astropy_model(lc.time)

    # This is a Gaussian likelihood, for independent data points

    if (0.0 <= astropy_model.radius <= 1.0) and (lc.time[0] <= astropy_model.t0 <= lc.time[-1] ) and (1.0 <= astropy_model.a <= 200.0 ):
        chisq = np.nansum((lc.flux - model)**2/(lc.flux_err)**2)
        lnp = np.nansum(1/np.sqrt(2*np.pi*(lc.flux_err))) - 0.5*chisq

        return lnp

    return -np.inf

def mcmc_fit(astropy_model, lc):

    '''
    This function is a

    Parameters
    ----------

    lc: LightCurve object
        This is a `lightkurve`-style LightCurve object, which contains
        the attributes `lc.time` (times in JD) and `lc.flux` (the brightness
        of the star), as well as lots of methods for analysis and plotting.

    astropy_model: An 'astropy model' object
        This model obect contains all the model parameters, their names,
        and their bounds if they are free parameters. It interfaces
        with a custom model to generate the function of interest,
        which is a BATMAN light curve model in this case.


    Returns
    -------

    max_likelihood: A dictionary
        This dictionary contains the names of the variable parameters,
        as well as a 3-element list of the maximum likelihood value,
        and +/- 1 sigma uncertainties.

    sampler: EnsembleSampler Object
        This object has several capabilities. In this MCMC, it is primarily
        used to run the emcee function and give us access to sample parameter
        values generated by the Monte Carlo.
    
    '''

    fold_check = input(["Is your light curve folded? (y/n)"])

    if fold_check == "n":
        lc = lc.fold(period = astropy_model.period.value)
        print("That's okay, I did it for you")

    norm_check = input(["Is your light curve normalized? (y/n)"])

    if norm_check_check == "n":
        lc = lc.normalize()
        print("Do I have to do everything?")

    organized = dict(period = astropy_model.period, t0 = astropy_model.t0,
                 radius = astropy_model.radius, a = astropy_model.a,
                 b = astropy_model.b, baseline = astropy_model.baseline,
                 ld1 = astropy_model.ld1, ld2 = astropy_model.ld2)

    variable_names = []
    i = 0
    for k in astropy_model.param_names:
        if astropy_model.fixed[k] == False:
            variable_names.append(str(k))
            i += 1

    ndim, nwalkers, nsteps = i, 100, 10000
    burnin = int(0.2*nsteps)

    param_initial = []
    for k in astropy_model.param_names:
        if organized[k].fixed == False:
            bounds = organized[k].bounds
            organized[k].initialwalkers = np.random.uniform(bounds[0],bounds[1],nwalkers)
            param_initial.append(organized[k].initialwalkers)

    p0 = np.transpose(param_initial)

    sampler = emcee.EnsembleSampler(nwalkers, ndim, lnprob)
    result = sampler.run_mcmc(p0, nsteps)

    max_likelihood = {}

    for j in range(i):
        param_samples = sampler.flatchain[int(nsteps*nwalkers/i):,j]
        max_likelihood[variable_names[j]] = np.percentile(param_samples, [16., 50., 84.])

    return max_likelihood,sampler
